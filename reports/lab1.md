# lab1实验报告

# 编程作业

通过修改TaskControlBlock结构体，添加了需要记录的信息，然后添加了对应的辅助函数，然后在系统调用中调用其计算需要的值返回即可。

功能总体就是实现一个系统调用，不难。

# 问答作业

## 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 三个 bad 测例 (ch2b_bad_*.rs) ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。

SBI版本：RustSBI-QEMU Version 0.2.0-alpha.2

ch2b_bad_address:程序希望将字符0写入地址0处，访问了错误的（或者说没有权限访问的）地址，也就是0地址处，因此被杀死了

ch2b_bad_instructions:程序使用了sret指令，这个指令是S态的返回指令，且会将特权级从S态降到U态，而用户程序所运行的所有代码都是在U态执行，没有S态的执行权限，因此无法执行sret指令，要返回应该使用ret指令

ch2b_bad_register:程序希望写S态的csr寄存器，但是程序所执行的每一条代码全部都是在U态执行，没有S态的权限，因此无法修改更高权限空间的寄存器，这是非法的，因此被掐掉了

## 深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:

### L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。

a0指向分配 Trap 上下文之后的内核栈栈顶。

两种情景：一种是切换上下文，一种是在第一次运行，内核初始化后运行一个我们构建好的trap转入用户态开始执行用户程序

### L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。

分别处理了sstatus、spec、sscratch寄存器。

sstatus给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息，这样我们能够查这个寄存器，降级后返回控制权，简而言之，就是能够到U态。

sepc记录 Trap 发生之前执行的最后一条指令的地址，我们在处理trap时，会将其+4或者设置为初始地址，总之，恢复到U态之后，pc将会被赋值为sepc继续执行。

用户栈的栈指针保存在 sscratch 中，需要在恢复的时候用到

### L50-L56：为何跳过了 x2 和 x4？

x2和x4是sp和tp，而在这之前，sp已经保存到sscratch中了，而用户栈的大小是已知的，因此tp也能计算得到，因此没必要保存

### L60：该指令之后，sp 和 sscratch 中的值分别有什么意义？

sp 重新指向用户栈栈顶，sscratch 也依然保存 进入 Trap 之前的状态并指向内核栈栈顶。

### __restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？

sret指令，因为检查了sstatus，发现是S，因此降级到U。

### L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？

sp指向的是内核栈。用户栈的栈指针保存在 sscratch 中。

因为下面要在内核中进行一系列的操作，因此需要把栈切换到内核的，用户的保存起来。

### 从 U 态进入 S 态是哪一条指令发生的？

ecall指令请求系统调用，随后发生一次中断，trap到S态。



# 荣誉准则

- 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

- 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

无

- 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

- 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

